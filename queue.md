# The Queue

The _queue_ is a mutable data structure representing the evolving state of the system.  It is alternately frozen and updated.  

- In the frozen phase the queue is input to a functional program that computes a collection of updates. This is called the _update function_.

- In the update phase, the previously computed updates are applied to the queue.

This cycle is repeated until a fixed point is reached (when there is no change to the queue contents).

## Inputs

When a fixed point has been reached, any updates generated by external effects are applied.

## Queue Organization

The queue is a database of immutable, timestamped _events_ with no duplicates.  A update is a command to add an event if it not present. 

Events are organized by, and can be accessed by:

- _type_  A type designates a relation or logical predicate.
- _index_ A value produced by an _index function_ applied to an event. 
- _phase_ The events added in the most recent update phase.
- _time_  Events with timestamp before or after a given time.

## Garbage Collection

Periodically, an update phase is used to purge events older than a given age.

## Outputs

An event type may be designated for output.  When a distinct event of of that type is added to the queue it produces an external effect. 

## Datalog Evaluator

An incremental datalog evaluator may be used as the update function. In outline:

- each event added in the most recent update phase is compared against each atom of each rule.
- any additional atoms of a matching rules are tested by querying the queue, ideally using index access.
- a matching rule generates an update

## Relational Algebra Evaluator

An alternative is to express the update function as a relational algebra expression.  This is reduced to datalog rules for incremental evaluation as follows:

- select and project operations correspond to single atom rules
- joins correspond to rules of two or more atoms
- intersections are encoded as joins
- unions correspond to two or more rules with the same head predicate
- recursion corresponds to a rule whose head has the same predicate as an atom in a precursor rule
